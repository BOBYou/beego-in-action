3. 模板
=========

在上一章中我们的 `beefer` 返回了 "Hello Beego" 的字符串作为 Http 的响应. 而在许多 Http 应用中,
我们需要用到模板.

# 为何我们需要模板

通常我们的 web 应用会包含不会随着请求的变化而变化的静态的内容, 以及可能随请求的不同而变化的动态的内容.
我们希望能够重用这些静态内容, 然后只改变那些动态的内容, 这时我们就需要用到模板.

我们接着来扩展 `beefer`, 给它加一个欢迎信息给不同的访问用户. 修改 `beefer.go` 的 Get() 方法:

```go
type User struct {
	Username string
}

// The Get method to handle the GET request
func (c *BeeferController) Get() {
	var tpl string = `
        <html>
            <head>
                <title>Beefer!</title>
            </head>
            <body>
                <strong>Hello, {{.User.Username}}</strong>
            </body>
        </html>
    `
	data := make(map[interface{}]interface{})
	user := User{Username: "Alice"}
	data["User"] = user

	t := template.New("Beefer Template")
	t = template.Must(t.Parse(tpl))

	t.Execute(c.Ctx.ResponseWriter, data)
}
```

本段代码的 [commit](https://github.com/lei-cao/beefer/commit/18085d29ce7b188ed50443816beab517e25f201c)

这里我们暂时新建了模拟对象 `User`. 然后定义了 `tpl` 模板, 里面 `{{.User.Username}}` 会根据用户的不同动态的输出数据.
接着我们通过模板的 `Execute` 函数用新建的 `user` 替换模板中的动态内容并输出到 `c.Ctx.ResponseWriter`.
如果你已经通过 `bee run` 启动了你的 `beefer`, 这时访问 [http://localhost:8080](http://localhost:8080)
你就会看到输出的 html 响应: "Hello, Alice"

# MVC 架构: 模板和控制器的分离

现在我们的模板文件和控制器逻辑还混在一起, 这样的代码结构在我们的应有有更多功能时, 会比较难维护.
我们希望能够将用来展示内容的模板和用来处理逻辑的控制器分离开, 从而使我们的代码有更好的组织结构.
我们可以将 `beefer` 改成这样的结构:

```
├── beefer.go
└── views
    └── beefer.tpl
```

我们将之前在 `tpl` string 变量里的内容移到 `views/beefer.tpl` 文件中. 并修改 `Get()` 方法如下:

```go
func (c *BeeferController) Get() {
	user := User{Username: "Alice"}
	c.Data["User"] = user

	c.TplNames = "beefer.tpl"
}
```

本段代码的 [commit](https://github.com/lei-cao/beefer/commit/a684101e1206db40eecfec250829f8ad470403a4)


重新刷新浏览器, 我们会得到相同的结果: "Hello, Alice".

`beego` 的默认模板引擎就是 `Go` 原生的 `template` 包. 关于 `template` 更多的使用可以参考:

[模板处理](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/07.4.md)

[beego 模板语法指南](https://github.com/Unknwon/gcblog/blob/master/content/03-beego-template.md)

下一章我们将给 `beefer` 应用样式.
